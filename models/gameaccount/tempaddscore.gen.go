// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gameaccount

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newTempaddscore(db *gorm.DB, opts ...gen.DOOption) tempaddscore {
	_tempaddscore := tempaddscore{}

	_tempaddscore.tempaddscoreDo.UseDB(db, opts...)
	_tempaddscore.tempaddscoreDo.UseModel(&model.Tempaddscore{})

	tableName := _tempaddscore.tempaddscoreDo.TableName()
	_tempaddscore.ALL = field.NewAsterisk(tableName)
	_tempaddscore.UserID = field.NewInt32(tableName, "userId")
	_tempaddscore.Score = field.NewInt32(tableName, "score")
	_tempaddscore.ChangeType = field.NewInt32(tableName, "change_type")

	_tempaddscore.fillFieldMap()

	return _tempaddscore
}

type tempaddscore struct {
	tempaddscoreDo

	ALL        field.Asterisk
	UserID     field.Int32
	Score      field.Int32
	ChangeType field.Int32

	fieldMap map[string]field.Expr
}

func (t tempaddscore) Table(newTableName string) *tempaddscore {
	t.tempaddscoreDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tempaddscore) As(alias string) *tempaddscore {
	t.tempaddscoreDo.DO = *(t.tempaddscoreDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tempaddscore) updateTableName(table string) *tempaddscore {
	t.ALL = field.NewAsterisk(table)
	t.UserID = field.NewInt32(table, "userId")
	t.Score = field.NewInt32(table, "score")
	t.ChangeType = field.NewInt32(table, "change_type")

	t.fillFieldMap()

	return t
}

func (t *tempaddscore) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tempaddscore) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 3)
	t.fieldMap["userId"] = t.UserID
	t.fieldMap["score"] = t.Score
	t.fieldMap["change_type"] = t.ChangeType
}

func (t tempaddscore) clone(db *gorm.DB) tempaddscore {
	t.tempaddscoreDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tempaddscore) replaceDB(db *gorm.DB) tempaddscore {
	t.tempaddscoreDo.ReplaceDB(db)
	return t
}

type tempaddscoreDo struct{ gen.DO }

type ITempaddscoreDo interface {
	gen.SubQuery
	Debug() ITempaddscoreDo
	WithContext(ctx context.Context) ITempaddscoreDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITempaddscoreDo
	WriteDB() ITempaddscoreDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITempaddscoreDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITempaddscoreDo
	Not(conds ...gen.Condition) ITempaddscoreDo
	Or(conds ...gen.Condition) ITempaddscoreDo
	Select(conds ...field.Expr) ITempaddscoreDo
	Where(conds ...gen.Condition) ITempaddscoreDo
	Order(conds ...field.Expr) ITempaddscoreDo
	Distinct(cols ...field.Expr) ITempaddscoreDo
	Omit(cols ...field.Expr) ITempaddscoreDo
	Join(table schema.Tabler, on ...field.Expr) ITempaddscoreDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITempaddscoreDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITempaddscoreDo
	Group(cols ...field.Expr) ITempaddscoreDo
	Having(conds ...gen.Condition) ITempaddscoreDo
	Limit(limit int) ITempaddscoreDo
	Offset(offset int) ITempaddscoreDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITempaddscoreDo
	Unscoped() ITempaddscoreDo
	Create(values ...*model.Tempaddscore) error
	CreateInBatches(values []*model.Tempaddscore, batchSize int) error
	Save(values ...*model.Tempaddscore) error
	First() (*model.Tempaddscore, error)
	Take() (*model.Tempaddscore, error)
	Last() (*model.Tempaddscore, error)
	Find() ([]*model.Tempaddscore, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Tempaddscore, err error)
	FindInBatches(result *[]*model.Tempaddscore, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Tempaddscore) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITempaddscoreDo
	Assign(attrs ...field.AssignExpr) ITempaddscoreDo
	Joins(fields ...field.RelationField) ITempaddscoreDo
	Preload(fields ...field.RelationField) ITempaddscoreDo
	FirstOrInit() (*model.Tempaddscore, error)
	FirstOrCreate() (*model.Tempaddscore, error)
	FindByPage(offset int, limit int) (result []*model.Tempaddscore, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITempaddscoreDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tempaddscoreDo) Debug() ITempaddscoreDo {
	return t.withDO(t.DO.Debug())
}

func (t tempaddscoreDo) WithContext(ctx context.Context) ITempaddscoreDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tempaddscoreDo) ReadDB() ITempaddscoreDo {
	return t.Clauses(dbresolver.Read)
}

func (t tempaddscoreDo) WriteDB() ITempaddscoreDo {
	return t.Clauses(dbresolver.Write)
}

func (t tempaddscoreDo) Session(config *gorm.Session) ITempaddscoreDo {
	return t.withDO(t.DO.Session(config))
}

func (t tempaddscoreDo) Clauses(conds ...clause.Expression) ITempaddscoreDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tempaddscoreDo) Returning(value interface{}, columns ...string) ITempaddscoreDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tempaddscoreDo) Not(conds ...gen.Condition) ITempaddscoreDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tempaddscoreDo) Or(conds ...gen.Condition) ITempaddscoreDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tempaddscoreDo) Select(conds ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tempaddscoreDo) Where(conds ...gen.Condition) ITempaddscoreDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tempaddscoreDo) Order(conds ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tempaddscoreDo) Distinct(cols ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tempaddscoreDo) Omit(cols ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tempaddscoreDo) Join(table schema.Tabler, on ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tempaddscoreDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tempaddscoreDo) RightJoin(table schema.Tabler, on ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tempaddscoreDo) Group(cols ...field.Expr) ITempaddscoreDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tempaddscoreDo) Having(conds ...gen.Condition) ITempaddscoreDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tempaddscoreDo) Limit(limit int) ITempaddscoreDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tempaddscoreDo) Offset(offset int) ITempaddscoreDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tempaddscoreDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITempaddscoreDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tempaddscoreDo) Unscoped() ITempaddscoreDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tempaddscoreDo) Create(values ...*model.Tempaddscore) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tempaddscoreDo) CreateInBatches(values []*model.Tempaddscore, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tempaddscoreDo) Save(values ...*model.Tempaddscore) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tempaddscoreDo) First() (*model.Tempaddscore, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Tempaddscore), nil
	}
}

func (t tempaddscoreDo) Take() (*model.Tempaddscore, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Tempaddscore), nil
	}
}

func (t tempaddscoreDo) Last() (*model.Tempaddscore, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Tempaddscore), nil
	}
}

func (t tempaddscoreDo) Find() ([]*model.Tempaddscore, error) {
	result, err := t.DO.Find()
	return result.([]*model.Tempaddscore), err
}

func (t tempaddscoreDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Tempaddscore, err error) {
	buf := make([]*model.Tempaddscore, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tempaddscoreDo) FindInBatches(result *[]*model.Tempaddscore, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tempaddscoreDo) Attrs(attrs ...field.AssignExpr) ITempaddscoreDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tempaddscoreDo) Assign(attrs ...field.AssignExpr) ITempaddscoreDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tempaddscoreDo) Joins(fields ...field.RelationField) ITempaddscoreDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tempaddscoreDo) Preload(fields ...field.RelationField) ITempaddscoreDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tempaddscoreDo) FirstOrInit() (*model.Tempaddscore, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Tempaddscore), nil
	}
}

func (t tempaddscoreDo) FirstOrCreate() (*model.Tempaddscore, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Tempaddscore), nil
	}
}

func (t tempaddscoreDo) FindByPage(offset int, limit int) (result []*model.Tempaddscore, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tempaddscoreDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tempaddscoreDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tempaddscoreDo) Delete(models ...*model.Tempaddscore) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tempaddscoreDo) withDO(do gen.Dao) *tempaddscoreDo {
	t.DO = *do.(*gen.DO)
	return t
}
