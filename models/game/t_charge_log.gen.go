// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package game

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newTChargeLog(db *gorm.DB, opts ...gen.DOOption) tChargeLog {
	_tChargeLog := tChargeLog{}

	_tChargeLog.tChargeLogDo.UseDB(db, opts...)
	_tChargeLog.tChargeLogDo.UseModel(&model.TChargeLog{})

	tableName := _tChargeLog.tChargeLogDo.TableName()
	_tChargeLog.ALL = field.NewAsterisk(tableName)
	_tChargeLog.ID = field.NewUint32(tableName, "id")
	_tChargeLog.Orderno = field.NewString(tableName, "orderno")
	_tChargeLog.Userid = field.NewInt32(tableName, "userid")
	_tChargeLog.GemsNum = field.NewUint32(tableName, "gems_num")
	_tChargeLog.CostMoney = field.NewUint32(tableName, "cost_money")
	_tChargeLog.ChargeType = field.NewString(tableName, "charge_type")
	_tChargeLog.Time = field.NewInt32(tableName, "time")
	_tChargeLog.GoldcoinExchangeRate = field.NewFloat64(tableName, "goldcoin_exchange_rate")

	_tChargeLog.fillFieldMap()

	return _tChargeLog
}

type tChargeLog struct {
	tChargeLogDo

	ALL                  field.Asterisk
	ID                   field.Uint32  // 充值id
	Orderno              field.String  // 订单号
	Userid               field.Int32   // 用户id
	GemsNum              field.Uint32  // 金币数量
	CostMoney            field.Uint32  // 花费的人民币总数
	ChargeType           field.String  // 0表示正常充值，1表示是促销活动，免费赠送
	Time                 field.Int32   // 充值时间
	GoldcoinExchangeRate field.Float64 // 当前的转换率

	fieldMap map[string]field.Expr
}

func (t tChargeLog) Table(newTableName string) *tChargeLog {
	t.tChargeLogDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tChargeLog) As(alias string) *tChargeLog {
	t.tChargeLogDo.DO = *(t.tChargeLogDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tChargeLog) updateTableName(table string) *tChargeLog {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewUint32(table, "id")
	t.Orderno = field.NewString(table, "orderno")
	t.Userid = field.NewInt32(table, "userid")
	t.GemsNum = field.NewUint32(table, "gems_num")
	t.CostMoney = field.NewUint32(table, "cost_money")
	t.ChargeType = field.NewString(table, "charge_type")
	t.Time = field.NewInt32(table, "time")
	t.GoldcoinExchangeRate = field.NewFloat64(table, "goldcoin_exchange_rate")

	t.fillFieldMap()

	return t
}

func (t *tChargeLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tChargeLog) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 8)
	t.fieldMap["id"] = t.ID
	t.fieldMap["orderno"] = t.Orderno
	t.fieldMap["userid"] = t.Userid
	t.fieldMap["gems_num"] = t.GemsNum
	t.fieldMap["cost_money"] = t.CostMoney
	t.fieldMap["charge_type"] = t.ChargeType
	t.fieldMap["time"] = t.Time
	t.fieldMap["goldcoin_exchange_rate"] = t.GoldcoinExchangeRate
}

func (t tChargeLog) clone(db *gorm.DB) tChargeLog {
	t.tChargeLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tChargeLog) replaceDB(db *gorm.DB) tChargeLog {
	t.tChargeLogDo.ReplaceDB(db)
	return t
}

type tChargeLogDo struct{ gen.DO }

type ITChargeLogDo interface {
	gen.SubQuery
	Debug() ITChargeLogDo
	WithContext(ctx context.Context) ITChargeLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITChargeLogDo
	WriteDB() ITChargeLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITChargeLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITChargeLogDo
	Not(conds ...gen.Condition) ITChargeLogDo
	Or(conds ...gen.Condition) ITChargeLogDo
	Select(conds ...field.Expr) ITChargeLogDo
	Where(conds ...gen.Condition) ITChargeLogDo
	Order(conds ...field.Expr) ITChargeLogDo
	Distinct(cols ...field.Expr) ITChargeLogDo
	Omit(cols ...field.Expr) ITChargeLogDo
	Join(table schema.Tabler, on ...field.Expr) ITChargeLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITChargeLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITChargeLogDo
	Group(cols ...field.Expr) ITChargeLogDo
	Having(conds ...gen.Condition) ITChargeLogDo
	Limit(limit int) ITChargeLogDo
	Offset(offset int) ITChargeLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITChargeLogDo
	Unscoped() ITChargeLogDo
	Create(values ...*model.TChargeLog) error
	CreateInBatches(values []*model.TChargeLog, batchSize int) error
	Save(values ...*model.TChargeLog) error
	First() (*model.TChargeLog, error)
	Take() (*model.TChargeLog, error)
	Last() (*model.TChargeLog, error)
	Find() ([]*model.TChargeLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TChargeLog, err error)
	FindInBatches(result *[]*model.TChargeLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TChargeLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITChargeLogDo
	Assign(attrs ...field.AssignExpr) ITChargeLogDo
	Joins(fields ...field.RelationField) ITChargeLogDo
	Preload(fields ...field.RelationField) ITChargeLogDo
	FirstOrInit() (*model.TChargeLog, error)
	FirstOrCreate() (*model.TChargeLog, error)
	FindByPage(offset int, limit int) (result []*model.TChargeLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITChargeLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tChargeLogDo) Debug() ITChargeLogDo {
	return t.withDO(t.DO.Debug())
}

func (t tChargeLogDo) WithContext(ctx context.Context) ITChargeLogDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tChargeLogDo) ReadDB() ITChargeLogDo {
	return t.Clauses(dbresolver.Read)
}

func (t tChargeLogDo) WriteDB() ITChargeLogDo {
	return t.Clauses(dbresolver.Write)
}

func (t tChargeLogDo) Session(config *gorm.Session) ITChargeLogDo {
	return t.withDO(t.DO.Session(config))
}

func (t tChargeLogDo) Clauses(conds ...clause.Expression) ITChargeLogDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tChargeLogDo) Returning(value interface{}, columns ...string) ITChargeLogDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tChargeLogDo) Not(conds ...gen.Condition) ITChargeLogDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tChargeLogDo) Or(conds ...gen.Condition) ITChargeLogDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tChargeLogDo) Select(conds ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tChargeLogDo) Where(conds ...gen.Condition) ITChargeLogDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tChargeLogDo) Order(conds ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tChargeLogDo) Distinct(cols ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tChargeLogDo) Omit(cols ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tChargeLogDo) Join(table schema.Tabler, on ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tChargeLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tChargeLogDo) RightJoin(table schema.Tabler, on ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tChargeLogDo) Group(cols ...field.Expr) ITChargeLogDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tChargeLogDo) Having(conds ...gen.Condition) ITChargeLogDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tChargeLogDo) Limit(limit int) ITChargeLogDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tChargeLogDo) Offset(offset int) ITChargeLogDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tChargeLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITChargeLogDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tChargeLogDo) Unscoped() ITChargeLogDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tChargeLogDo) Create(values ...*model.TChargeLog) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tChargeLogDo) CreateInBatches(values []*model.TChargeLog, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tChargeLogDo) Save(values ...*model.TChargeLog) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tChargeLogDo) First() (*model.TChargeLog, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChargeLog), nil
	}
}

func (t tChargeLogDo) Take() (*model.TChargeLog, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChargeLog), nil
	}
}

func (t tChargeLogDo) Last() (*model.TChargeLog, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChargeLog), nil
	}
}

func (t tChargeLogDo) Find() ([]*model.TChargeLog, error) {
	result, err := t.DO.Find()
	return result.([]*model.TChargeLog), err
}

func (t tChargeLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TChargeLog, err error) {
	buf := make([]*model.TChargeLog, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tChargeLogDo) FindInBatches(result *[]*model.TChargeLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tChargeLogDo) Attrs(attrs ...field.AssignExpr) ITChargeLogDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tChargeLogDo) Assign(attrs ...field.AssignExpr) ITChargeLogDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tChargeLogDo) Joins(fields ...field.RelationField) ITChargeLogDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tChargeLogDo) Preload(fields ...field.RelationField) ITChargeLogDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tChargeLogDo) FirstOrInit() (*model.TChargeLog, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChargeLog), nil
	}
}

func (t tChargeLogDo) FirstOrCreate() (*model.TChargeLog, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChargeLog), nil
	}
}

func (t tChargeLogDo) FindByPage(offset int, limit int) (result []*model.TChargeLog, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tChargeLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tChargeLogDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tChargeLogDo) Delete(models ...*model.TChargeLog) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tChargeLogDo) withDO(do gen.Dao) *tChargeLogDo {
	t.DO = *do.(*gen.DO)
	return t
}
