// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package landlords

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newMatchlog(db *gorm.DB, opts ...gen.DOOption) matchlog {
	_matchlog := matchlog{}

	_matchlog.matchlogDo.UseDB(db, opts...)
	_matchlog.matchlogDo.UseModel(&model.Matchlog{})

	tableName := _matchlog.matchlogDo.TableName()
	_matchlog.ALL = field.NewAsterisk(tableName)
	_matchlog.MatchID = field.NewInt32(tableName, "matchId")
	_matchlog.Open11 = field.NewString(tableName, "open11")
	_matchlog.Open12 = field.NewString(tableName, "open12")
	_matchlog.Open21 = field.NewString(tableName, "open21")
	_matchlog.Open22 = field.NewString(tableName, "open22")
	_matchlog.Open31 = field.NewString(tableName, "open31")
	_matchlog.Open32 = field.NewString(tableName, "open32")
	_matchlog.Open41 = field.NewString(tableName, "open41")
	_matchlog.Open42 = field.NewString(tableName, "open42")
	_matchlog.Open2winbet = field.NewInt32(tableName, "open2winbet")
	_matchlog.Open3winbet = field.NewInt32(tableName, "open3winbet")
	_matchlog.Open4winbet = field.NewInt32(tableName, "open4winbet")
	_matchlog.TableID = field.NewInt32(tableName, "tableId")
	_matchlog.ServeID = field.NewInt32(tableName, "serveId")
	_matchlog.Adddate = field.NewTime(tableName, "adddate")

	_matchlog.fillFieldMap()

	return _matchlog
}

type matchlog struct {
	matchlogDo

	ALL         field.Asterisk
	MatchID     field.Int32
	Open11      field.String
	Open12      field.String
	Open21      field.String
	Open22      field.String
	Open31      field.String
	Open32      field.String
	Open41      field.String
	Open42      field.String
	Open2winbet field.Int32
	Open3winbet field.Int32
	Open4winbet field.Int32
	TableID     field.Int32
	ServeID     field.Int32
	Adddate     field.Time

	fieldMap map[string]field.Expr
}

func (m matchlog) Table(newTableName string) *matchlog {
	m.matchlogDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m matchlog) As(alias string) *matchlog {
	m.matchlogDo.DO = *(m.matchlogDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *matchlog) updateTableName(table string) *matchlog {
	m.ALL = field.NewAsterisk(table)
	m.MatchID = field.NewInt32(table, "matchId")
	m.Open11 = field.NewString(table, "open11")
	m.Open12 = field.NewString(table, "open12")
	m.Open21 = field.NewString(table, "open21")
	m.Open22 = field.NewString(table, "open22")
	m.Open31 = field.NewString(table, "open31")
	m.Open32 = field.NewString(table, "open32")
	m.Open41 = field.NewString(table, "open41")
	m.Open42 = field.NewString(table, "open42")
	m.Open2winbet = field.NewInt32(table, "open2winbet")
	m.Open3winbet = field.NewInt32(table, "open3winbet")
	m.Open4winbet = field.NewInt32(table, "open4winbet")
	m.TableID = field.NewInt32(table, "tableId")
	m.ServeID = field.NewInt32(table, "serveId")
	m.Adddate = field.NewTime(table, "adddate")

	m.fillFieldMap()

	return m
}

func (m *matchlog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *matchlog) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 15)
	m.fieldMap["matchId"] = m.MatchID
	m.fieldMap["open11"] = m.Open11
	m.fieldMap["open12"] = m.Open12
	m.fieldMap["open21"] = m.Open21
	m.fieldMap["open22"] = m.Open22
	m.fieldMap["open31"] = m.Open31
	m.fieldMap["open32"] = m.Open32
	m.fieldMap["open41"] = m.Open41
	m.fieldMap["open42"] = m.Open42
	m.fieldMap["open2winbet"] = m.Open2winbet
	m.fieldMap["open3winbet"] = m.Open3winbet
	m.fieldMap["open4winbet"] = m.Open4winbet
	m.fieldMap["tableId"] = m.TableID
	m.fieldMap["serveId"] = m.ServeID
	m.fieldMap["adddate"] = m.Adddate
}

func (m matchlog) clone(db *gorm.DB) matchlog {
	m.matchlogDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m matchlog) replaceDB(db *gorm.DB) matchlog {
	m.matchlogDo.ReplaceDB(db)
	return m
}

type matchlogDo struct{ gen.DO }

type IMatchlogDo interface {
	gen.SubQuery
	Debug() IMatchlogDo
	WithContext(ctx context.Context) IMatchlogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMatchlogDo
	WriteDB() IMatchlogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMatchlogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMatchlogDo
	Not(conds ...gen.Condition) IMatchlogDo
	Or(conds ...gen.Condition) IMatchlogDo
	Select(conds ...field.Expr) IMatchlogDo
	Where(conds ...gen.Condition) IMatchlogDo
	Order(conds ...field.Expr) IMatchlogDo
	Distinct(cols ...field.Expr) IMatchlogDo
	Omit(cols ...field.Expr) IMatchlogDo
	Join(table schema.Tabler, on ...field.Expr) IMatchlogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMatchlogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMatchlogDo
	Group(cols ...field.Expr) IMatchlogDo
	Having(conds ...gen.Condition) IMatchlogDo
	Limit(limit int) IMatchlogDo
	Offset(offset int) IMatchlogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMatchlogDo
	Unscoped() IMatchlogDo
	Create(values ...*model.Matchlog) error
	CreateInBatches(values []*model.Matchlog, batchSize int) error
	Save(values ...*model.Matchlog) error
	First() (*model.Matchlog, error)
	Take() (*model.Matchlog, error)
	Last() (*model.Matchlog, error)
	Find() ([]*model.Matchlog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Matchlog, err error)
	FindInBatches(result *[]*model.Matchlog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Matchlog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMatchlogDo
	Assign(attrs ...field.AssignExpr) IMatchlogDo
	Joins(fields ...field.RelationField) IMatchlogDo
	Preload(fields ...field.RelationField) IMatchlogDo
	FirstOrInit() (*model.Matchlog, error)
	FirstOrCreate() (*model.Matchlog, error)
	FindByPage(offset int, limit int) (result []*model.Matchlog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMatchlogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m matchlogDo) Debug() IMatchlogDo {
	return m.withDO(m.DO.Debug())
}

func (m matchlogDo) WithContext(ctx context.Context) IMatchlogDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m matchlogDo) ReadDB() IMatchlogDo {
	return m.Clauses(dbresolver.Read)
}

func (m matchlogDo) WriteDB() IMatchlogDo {
	return m.Clauses(dbresolver.Write)
}

func (m matchlogDo) Session(config *gorm.Session) IMatchlogDo {
	return m.withDO(m.DO.Session(config))
}

func (m matchlogDo) Clauses(conds ...clause.Expression) IMatchlogDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m matchlogDo) Returning(value interface{}, columns ...string) IMatchlogDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m matchlogDo) Not(conds ...gen.Condition) IMatchlogDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m matchlogDo) Or(conds ...gen.Condition) IMatchlogDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m matchlogDo) Select(conds ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m matchlogDo) Where(conds ...gen.Condition) IMatchlogDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m matchlogDo) Order(conds ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m matchlogDo) Distinct(cols ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m matchlogDo) Omit(cols ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m matchlogDo) Join(table schema.Tabler, on ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m matchlogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m matchlogDo) RightJoin(table schema.Tabler, on ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m matchlogDo) Group(cols ...field.Expr) IMatchlogDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m matchlogDo) Having(conds ...gen.Condition) IMatchlogDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m matchlogDo) Limit(limit int) IMatchlogDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m matchlogDo) Offset(offset int) IMatchlogDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m matchlogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMatchlogDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m matchlogDo) Unscoped() IMatchlogDo {
	return m.withDO(m.DO.Unscoped())
}

func (m matchlogDo) Create(values ...*model.Matchlog) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m matchlogDo) CreateInBatches(values []*model.Matchlog, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m matchlogDo) Save(values ...*model.Matchlog) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m matchlogDo) First() (*model.Matchlog, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchlog), nil
	}
}

func (m matchlogDo) Take() (*model.Matchlog, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchlog), nil
	}
}

func (m matchlogDo) Last() (*model.Matchlog, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchlog), nil
	}
}

func (m matchlogDo) Find() ([]*model.Matchlog, error) {
	result, err := m.DO.Find()
	return result.([]*model.Matchlog), err
}

func (m matchlogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Matchlog, err error) {
	buf := make([]*model.Matchlog, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m matchlogDo) FindInBatches(result *[]*model.Matchlog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m matchlogDo) Attrs(attrs ...field.AssignExpr) IMatchlogDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m matchlogDo) Assign(attrs ...field.AssignExpr) IMatchlogDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m matchlogDo) Joins(fields ...field.RelationField) IMatchlogDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m matchlogDo) Preload(fields ...field.RelationField) IMatchlogDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m matchlogDo) FirstOrInit() (*model.Matchlog, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchlog), nil
	}
}

func (m matchlogDo) FirstOrCreate() (*model.Matchlog, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchlog), nil
	}
}

func (m matchlogDo) FindByPage(offset int, limit int) (result []*model.Matchlog, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m matchlogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m matchlogDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m matchlogDo) Delete(models ...*model.Matchlog) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *matchlogDo) withDO(do gen.Dao) *matchlogDo {
	m.DO = *do.(*gen.DO)
	return m
}
