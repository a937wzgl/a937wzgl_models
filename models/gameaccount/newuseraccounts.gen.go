// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gameaccount

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newNewuseraccount(db *gorm.DB, opts ...gen.DOOption) newuseraccount {
	_newuseraccount := newuseraccount{}

	_newuseraccount.newuseraccountDo.UseDB(db, opts...)
	_newuseraccount.newuseraccountDo.UseModel(&model.Newuseraccount{})

	tableName := _newuseraccount.newuseraccountDo.TableName()
	_newuseraccount.ALL = field.NewAsterisk(tableName)
	_newuseraccount.ID = field.NewInt32(tableName, "Id")
	_newuseraccount.Account = field.NewString(tableName, "Account")
	_newuseraccount.Password = field.NewString(tableName, "Password")
	_newuseraccount.Nickname = field.NewString(tableName, "nickname")
	_newuseraccount.Score = field.NewUint32(tableName, "score")
	_newuseraccount.AddDate = field.NewTime(tableName, "AddDate")
	_newuseraccount.LoginCount = field.NewUint32(tableName, "LoginCount")
	_newuseraccount.P = field.NewString(tableName, "p")
	_newuseraccount.Diamond = field.NewUint32(tableName, "diamond")
	_newuseraccount.GiftTicket = field.NewInt32(tableName, "giftTicket")
	_newuseraccount.PhoneNo = field.NewString(tableName, "phoneNo")
	_newuseraccount.Email = field.NewString(tableName, "email")
	_newuseraccount.Sex = field.NewInt32(tableName, "sex")
	_newuseraccount.City = field.NewString(tableName, "city")
	_newuseraccount.Province = field.NewString(tableName, "province")
	_newuseraccount.Country = field.NewString(tableName, "country")
	_newuseraccount.Headimgurl = field.NewString(tableName, "headimgurl")
	_newuseraccount.Language = field.NewString(tableName, "language")
	_newuseraccount.Robot = field.NewBool(tableName, "Robot")
	_newuseraccount.ChannelType = field.NewString(tableName, "ChannelType")
	_newuseraccount.Official = field.NewBool(tableName, "official")
	_newuseraccount.Gametoken = field.NewString(tableName, "gametoken")
	_newuseraccount.Qdid = field.NewUint32(tableName, "qdid")
	_newuseraccount.Housecard = field.NewUint32(tableName, "housecard")
	_newuseraccount.TotalRecharge = field.NewFloat64(tableName, "totalRecharge")
	_newuseraccount.Loginip = field.NewString(tableName, "loginip")
	_newuseraccount.Iscanlogin = field.NewBool(tableName, "iscanlogin")
	_newuseraccount.DianshaScore = field.NewUint32(tableName, "diansha_score")
	_newuseraccount.DianshaGameids = field.NewString(tableName, "diansha_gameids")
	_newuseraccount.IsVip = field.NewBool(tableName, "is_vip")
	_newuseraccount.G4UID = field.NewString(tableName, "g4_uid")
	_newuseraccount.AccountUsing = field.NewInt32(tableName, "account_using")

	_newuseraccount.fillFieldMap()

	return _newuseraccount
}

type newuseraccount struct {
	newuseraccountDo

	ALL            field.Asterisk
	ID             field.Int32
	Account        field.String
	Password       field.String
	Nickname       field.String
	Score          field.Uint32
	AddDate        field.Time
	LoginCount     field.Uint32
	P              field.String
	Diamond        field.Uint32
	GiftTicket     field.Int32
	PhoneNo        field.String
	Email          field.String
	Sex            field.Int32
	City           field.String
	Province       field.String
	Country        field.String
	Headimgurl     field.String
	Language       field.String
	Robot          field.Bool
	ChannelType    field.String
	Official       field.Bool
	Gametoken      field.String
	Qdid           field.Uint32 // 渠道id
	Housecard      field.Uint32
	TotalRecharge  field.Float64
	Loginip        field.String
	Iscanlogin     field.Bool // 1 can 0 no
	DianshaScore   field.Uint32
	DianshaGameids field.String
	IsVip          field.Bool // 0 1
	G4UID          field.String
	AccountUsing   field.Int32

	fieldMap map[string]field.Expr
}

func (n newuseraccount) Table(newTableName string) *newuseraccount {
	n.newuseraccountDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n newuseraccount) As(alias string) *newuseraccount {
	n.newuseraccountDo.DO = *(n.newuseraccountDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *newuseraccount) updateTableName(table string) *newuseraccount {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewInt32(table, "Id")
	n.Account = field.NewString(table, "Account")
	n.Password = field.NewString(table, "Password")
	n.Nickname = field.NewString(table, "nickname")
	n.Score = field.NewUint32(table, "score")
	n.AddDate = field.NewTime(table, "AddDate")
	n.LoginCount = field.NewUint32(table, "LoginCount")
	n.P = field.NewString(table, "p")
	n.Diamond = field.NewUint32(table, "diamond")
	n.GiftTicket = field.NewInt32(table, "giftTicket")
	n.PhoneNo = field.NewString(table, "phoneNo")
	n.Email = field.NewString(table, "email")
	n.Sex = field.NewInt32(table, "sex")
	n.City = field.NewString(table, "city")
	n.Province = field.NewString(table, "province")
	n.Country = field.NewString(table, "country")
	n.Headimgurl = field.NewString(table, "headimgurl")
	n.Language = field.NewString(table, "language")
	n.Robot = field.NewBool(table, "Robot")
	n.ChannelType = field.NewString(table, "ChannelType")
	n.Official = field.NewBool(table, "official")
	n.Gametoken = field.NewString(table, "gametoken")
	n.Qdid = field.NewUint32(table, "qdid")
	n.Housecard = field.NewUint32(table, "housecard")
	n.TotalRecharge = field.NewFloat64(table, "totalRecharge")
	n.Loginip = field.NewString(table, "loginip")
	n.Iscanlogin = field.NewBool(table, "iscanlogin")
	n.DianshaScore = field.NewUint32(table, "diansha_score")
	n.DianshaGameids = field.NewString(table, "diansha_gameids")
	n.IsVip = field.NewBool(table, "is_vip")
	n.G4UID = field.NewString(table, "g4_uid")
	n.AccountUsing = field.NewInt32(table, "account_using")

	n.fillFieldMap()

	return n
}

func (n *newuseraccount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *newuseraccount) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 32)
	n.fieldMap["Id"] = n.ID
	n.fieldMap["Account"] = n.Account
	n.fieldMap["Password"] = n.Password
	n.fieldMap["nickname"] = n.Nickname
	n.fieldMap["score"] = n.Score
	n.fieldMap["AddDate"] = n.AddDate
	n.fieldMap["LoginCount"] = n.LoginCount
	n.fieldMap["p"] = n.P
	n.fieldMap["diamond"] = n.Diamond
	n.fieldMap["giftTicket"] = n.GiftTicket
	n.fieldMap["phoneNo"] = n.PhoneNo
	n.fieldMap["email"] = n.Email
	n.fieldMap["sex"] = n.Sex
	n.fieldMap["city"] = n.City
	n.fieldMap["province"] = n.Province
	n.fieldMap["country"] = n.Country
	n.fieldMap["headimgurl"] = n.Headimgurl
	n.fieldMap["language"] = n.Language
	n.fieldMap["Robot"] = n.Robot
	n.fieldMap["ChannelType"] = n.ChannelType
	n.fieldMap["official"] = n.Official
	n.fieldMap["gametoken"] = n.Gametoken
	n.fieldMap["qdid"] = n.Qdid
	n.fieldMap["housecard"] = n.Housecard
	n.fieldMap["totalRecharge"] = n.TotalRecharge
	n.fieldMap["loginip"] = n.Loginip
	n.fieldMap["iscanlogin"] = n.Iscanlogin
	n.fieldMap["diansha_score"] = n.DianshaScore
	n.fieldMap["diansha_gameids"] = n.DianshaGameids
	n.fieldMap["is_vip"] = n.IsVip
	n.fieldMap["g4_uid"] = n.G4UID
	n.fieldMap["account_using"] = n.AccountUsing
}

func (n newuseraccount) clone(db *gorm.DB) newuseraccount {
	n.newuseraccountDo.ReplaceConnPool(db.Statement.ConnPool)
	return n
}

func (n newuseraccount) replaceDB(db *gorm.DB) newuseraccount {
	n.newuseraccountDo.ReplaceDB(db)
	return n
}

type newuseraccountDo struct{ gen.DO }

type INewuseraccountDo interface {
	gen.SubQuery
	Debug() INewuseraccountDo
	WithContext(ctx context.Context) INewuseraccountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() INewuseraccountDo
	WriteDB() INewuseraccountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) INewuseraccountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INewuseraccountDo
	Not(conds ...gen.Condition) INewuseraccountDo
	Or(conds ...gen.Condition) INewuseraccountDo
	Select(conds ...field.Expr) INewuseraccountDo
	Where(conds ...gen.Condition) INewuseraccountDo
	Order(conds ...field.Expr) INewuseraccountDo
	Distinct(cols ...field.Expr) INewuseraccountDo
	Omit(cols ...field.Expr) INewuseraccountDo
	Join(table schema.Tabler, on ...field.Expr) INewuseraccountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INewuseraccountDo
	RightJoin(table schema.Tabler, on ...field.Expr) INewuseraccountDo
	Group(cols ...field.Expr) INewuseraccountDo
	Having(conds ...gen.Condition) INewuseraccountDo
	Limit(limit int) INewuseraccountDo
	Offset(offset int) INewuseraccountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INewuseraccountDo
	Unscoped() INewuseraccountDo
	Create(values ...*model.Newuseraccount) error
	CreateInBatches(values []*model.Newuseraccount, batchSize int) error
	Save(values ...*model.Newuseraccount) error
	First() (*model.Newuseraccount, error)
	Take() (*model.Newuseraccount, error)
	Last() (*model.Newuseraccount, error)
	Find() ([]*model.Newuseraccount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Newuseraccount, err error)
	FindInBatches(result *[]*model.Newuseraccount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Newuseraccount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INewuseraccountDo
	Assign(attrs ...field.AssignExpr) INewuseraccountDo
	Joins(fields ...field.RelationField) INewuseraccountDo
	Preload(fields ...field.RelationField) INewuseraccountDo
	FirstOrInit() (*model.Newuseraccount, error)
	FirstOrCreate() (*model.Newuseraccount, error)
	FindByPage(offset int, limit int) (result []*model.Newuseraccount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INewuseraccountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n newuseraccountDo) Debug() INewuseraccountDo {
	return n.withDO(n.DO.Debug())
}

func (n newuseraccountDo) WithContext(ctx context.Context) INewuseraccountDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n newuseraccountDo) ReadDB() INewuseraccountDo {
	return n.Clauses(dbresolver.Read)
}

func (n newuseraccountDo) WriteDB() INewuseraccountDo {
	return n.Clauses(dbresolver.Write)
}

func (n newuseraccountDo) Session(config *gorm.Session) INewuseraccountDo {
	return n.withDO(n.DO.Session(config))
}

func (n newuseraccountDo) Clauses(conds ...clause.Expression) INewuseraccountDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n newuseraccountDo) Returning(value interface{}, columns ...string) INewuseraccountDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n newuseraccountDo) Not(conds ...gen.Condition) INewuseraccountDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n newuseraccountDo) Or(conds ...gen.Condition) INewuseraccountDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n newuseraccountDo) Select(conds ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n newuseraccountDo) Where(conds ...gen.Condition) INewuseraccountDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n newuseraccountDo) Order(conds ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n newuseraccountDo) Distinct(cols ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n newuseraccountDo) Omit(cols ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n newuseraccountDo) Join(table schema.Tabler, on ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n newuseraccountDo) LeftJoin(table schema.Tabler, on ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n newuseraccountDo) RightJoin(table schema.Tabler, on ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n newuseraccountDo) Group(cols ...field.Expr) INewuseraccountDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n newuseraccountDo) Having(conds ...gen.Condition) INewuseraccountDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n newuseraccountDo) Limit(limit int) INewuseraccountDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n newuseraccountDo) Offset(offset int) INewuseraccountDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n newuseraccountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INewuseraccountDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n newuseraccountDo) Unscoped() INewuseraccountDo {
	return n.withDO(n.DO.Unscoped())
}

func (n newuseraccountDo) Create(values ...*model.Newuseraccount) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n newuseraccountDo) CreateInBatches(values []*model.Newuseraccount, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n newuseraccountDo) Save(values ...*model.Newuseraccount) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n newuseraccountDo) First() (*model.Newuseraccount, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Newuseraccount), nil
	}
}

func (n newuseraccountDo) Take() (*model.Newuseraccount, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Newuseraccount), nil
	}
}

func (n newuseraccountDo) Last() (*model.Newuseraccount, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Newuseraccount), nil
	}
}

func (n newuseraccountDo) Find() ([]*model.Newuseraccount, error) {
	result, err := n.DO.Find()
	return result.([]*model.Newuseraccount), err
}

func (n newuseraccountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Newuseraccount, err error) {
	buf := make([]*model.Newuseraccount, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n newuseraccountDo) FindInBatches(result *[]*model.Newuseraccount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n newuseraccountDo) Attrs(attrs ...field.AssignExpr) INewuseraccountDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n newuseraccountDo) Assign(attrs ...field.AssignExpr) INewuseraccountDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n newuseraccountDo) Joins(fields ...field.RelationField) INewuseraccountDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n newuseraccountDo) Preload(fields ...field.RelationField) INewuseraccountDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n newuseraccountDo) FirstOrInit() (*model.Newuseraccount, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Newuseraccount), nil
	}
}

func (n newuseraccountDo) FirstOrCreate() (*model.Newuseraccount, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Newuseraccount), nil
	}
}

func (n newuseraccountDo) FindByPage(offset int, limit int) (result []*model.Newuseraccount, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n newuseraccountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n newuseraccountDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n newuseraccountDo) Delete(models ...*model.Newuseraccount) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *newuseraccountDo) withDO(do gen.Dao) *newuseraccountDo {
	n.DO = *do.(*gen.DO)
	return n
}
