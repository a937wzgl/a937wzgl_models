// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fish

import (
	"context"
	"database/sql"
	"gorm.io/gorm"
)

// ProcedureCaller 存储过程调用器
type ProcedureCaller struct {
	db *gorm.DB
}

// NewProcedureCaller 创建存储过程调用器
func NewProcedureCaller(db *gorm.DB) *ProcedureCaller {
	return &ProcedureCaller{db: db}
}

// NewFishProcedureCaller 创建 FISH 数据库的存储过程调用器
func NewFishProcedureCaller(db *gorm.DB) *ProcedureCaller {
	return &ProcedureCaller{db: db}
}

// Addfishlog 调用存储过程 addFishlog
func (pc *ProcedureCaller) Addfishlog(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL addFishlog()").Error
}

// AddfishlogWithResult 调用存储过程 addFishlog 并返回结果
func (pc *ProcedureCaller) AddfishlogWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL addFishlog()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Calculaterank 调用存储过程 calculateRank
func (pc *ProcedureCaller) Calculaterank(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL calculateRank()").Error
}

// CalculaterankWithResult 调用存储过程 calculateRank 并返回结果
func (pc *ProcedureCaller) CalculaterankWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL calculateRank()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Getdayprize 调用存储过程 getdayprize
func (pc *ProcedureCaller) Getdayprize(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL getdayprize()").Error
}

// GetdayprizeWithResult 调用存储过程 getdayprize 并返回结果
func (pc *ProcedureCaller) GetdayprizeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL getdayprize()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Getmatchrandking 调用存储过程 getMatchRandKing
func (pc *ProcedureCaller) Getmatchrandking(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL getMatchRandKing()").Error
}

// GetmatchrandkingWithResult 调用存储过程 getMatchRandKing 并返回结果
func (pc *ProcedureCaller) GetmatchrandkingWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL getMatchRandKing()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Sendprize 调用存储过程 sendPrize
func (pc *ProcedureCaller) Sendprize(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL sendPrize()").Error
}

// SendprizeWithResult 调用存储过程 sendPrize 并返回结果
func (pc *ProcedureCaller) SendprizeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL sendPrize()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Singleuq 调用存储过程 SingleUQ
func (pc *ProcedureCaller) Singleuq(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL SingleUQ()").Error
}

// SingleuqWithResult 调用存储过程 SingleUQ 并返回结果
func (pc *ProcedureCaller) SingleuqWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL SingleUQ()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Updatematchrandking 调用存储过程 updateMatchRandKing
func (pc *ProcedureCaller) Updatematchrandking(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL updateMatchRandKing()").Error
}

// UpdatematchrandkingWithResult 调用存储过程 updateMatchRandKing 并返回结果
func (pc *ProcedureCaller) UpdatematchrandkingWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL updateMatchRandKing()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Updateprop 调用存储过程 updateProp
func (pc *ProcedureCaller) Updateprop(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL updateProp()").Error
}

// UpdatepropWithResult 调用存储过程 updateProp 并返回结果
func (pc *ProcedureCaller) UpdatepropWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL updateProp()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Transaction 执行事务中的存储过程
func (pc *ProcedureCaller) Transaction(fc func(tx *ProcedureCaller) error, opts ...*sql.TxOptions) error {
	return pc.db.Transaction(func(tx *gorm.DB) error {
		return fc(NewProcedureCaller(tx))
	}, opts...)
}

// WithContext 设置上下文
func (pc *ProcedureCaller) WithContext(ctx context.Context) *ProcedureCaller {
	return &ProcedureCaller{db: pc.db.WithContext(ctx)}
}
