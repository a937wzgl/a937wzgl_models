// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package game

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newTUsersRechangeRecord(db *gorm.DB, opts ...gen.DOOption) tUsersRechangeRecord {
	_tUsersRechangeRecord := tUsersRechangeRecord{}

	_tUsersRechangeRecord.tUsersRechangeRecordDo.UseDB(db, opts...)
	_tUsersRechangeRecord.tUsersRechangeRecordDo.UseModel(&model.TUsersRechangeRecord{})

	tableName := _tUsersRechangeRecord.tUsersRechangeRecordDo.TableName()
	_tUsersRechangeRecord.ALL = field.NewAsterisk(tableName)
	_tUsersRechangeRecord.ID = field.NewUint32(tableName, "id")
	_tUsersRechangeRecord.Userid = field.NewUint32(tableName, "userid")
	_tUsersRechangeRecord.Orderno = field.NewString(tableName, "orderno")
	_tUsersRechangeRecord.Money = field.NewFloat64(tableName, "money")
	_tUsersRechangeRecord.PayType = field.NewString(tableName, "pay_type")
	_tUsersRechangeRecord.Status = field.NewInt32(tableName, "status")
	_tUsersRechangeRecord.Time = field.NewInt32(tableName, "time")
	_tUsersRechangeRecord.Result = field.NewString(tableName, "result")
	_tUsersRechangeRecord.NotifyResult = field.NewString(tableName, "notify_result")
	_tUsersRechangeRecord.IsAccount = field.NewInt32(tableName, "is_account")
	_tUsersRechangeRecord.AccountUserid = field.NewUint32(tableName, "account_userid")
	_tUsersRechangeRecord.AccountResult = field.NewString(tableName, "account_result")

	_tUsersRechangeRecord.fillFieldMap()

	return _tUsersRechangeRecord
}

type tUsersRechangeRecord struct {
	tUsersRechangeRecordDo

	ALL           field.Asterisk
	ID            field.Uint32  // 序号
	Userid        field.Uint32  // 用户
	Orderno       field.String  // 订单号
	Money         field.Float64 // 充值金额
	PayType       field.String  // 充值类型
	Status        field.Int32   // 状态(0：新  1：充值成功)
	Time          field.Int32   // 充值时间
	Result        field.String  // 返回值
	NotifyResult  field.String  // 异步返回值
	IsAccount     field.Int32   // 入帐标志（0：默认  1：已入帐  9:异常）
	AccountUserid field.Uint32  // 入帐人（客户的经纪人）
	AccountResult field.String  // 入帐返回值

	fieldMap map[string]field.Expr
}

func (t tUsersRechangeRecord) Table(newTableName string) *tUsersRechangeRecord {
	t.tUsersRechangeRecordDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tUsersRechangeRecord) As(alias string) *tUsersRechangeRecord {
	t.tUsersRechangeRecordDo.DO = *(t.tUsersRechangeRecordDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tUsersRechangeRecord) updateTableName(table string) *tUsersRechangeRecord {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewUint32(table, "id")
	t.Userid = field.NewUint32(table, "userid")
	t.Orderno = field.NewString(table, "orderno")
	t.Money = field.NewFloat64(table, "money")
	t.PayType = field.NewString(table, "pay_type")
	t.Status = field.NewInt32(table, "status")
	t.Time = field.NewInt32(table, "time")
	t.Result = field.NewString(table, "result")
	t.NotifyResult = field.NewString(table, "notify_result")
	t.IsAccount = field.NewInt32(table, "is_account")
	t.AccountUserid = field.NewUint32(table, "account_userid")
	t.AccountResult = field.NewString(table, "account_result")

	t.fillFieldMap()

	return t
}

func (t *tUsersRechangeRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tUsersRechangeRecord) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 12)
	t.fieldMap["id"] = t.ID
	t.fieldMap["userid"] = t.Userid
	t.fieldMap["orderno"] = t.Orderno
	t.fieldMap["money"] = t.Money
	t.fieldMap["pay_type"] = t.PayType
	t.fieldMap["status"] = t.Status
	t.fieldMap["time"] = t.Time
	t.fieldMap["result"] = t.Result
	t.fieldMap["notify_result"] = t.NotifyResult
	t.fieldMap["is_account"] = t.IsAccount
	t.fieldMap["account_userid"] = t.AccountUserid
	t.fieldMap["account_result"] = t.AccountResult
}

func (t tUsersRechangeRecord) clone(db *gorm.DB) tUsersRechangeRecord {
	t.tUsersRechangeRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tUsersRechangeRecord) replaceDB(db *gorm.DB) tUsersRechangeRecord {
	t.tUsersRechangeRecordDo.ReplaceDB(db)
	return t
}

type tUsersRechangeRecordDo struct{ gen.DO }

type ITUsersRechangeRecordDo interface {
	gen.SubQuery
	Debug() ITUsersRechangeRecordDo
	WithContext(ctx context.Context) ITUsersRechangeRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITUsersRechangeRecordDo
	WriteDB() ITUsersRechangeRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITUsersRechangeRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITUsersRechangeRecordDo
	Not(conds ...gen.Condition) ITUsersRechangeRecordDo
	Or(conds ...gen.Condition) ITUsersRechangeRecordDo
	Select(conds ...field.Expr) ITUsersRechangeRecordDo
	Where(conds ...gen.Condition) ITUsersRechangeRecordDo
	Order(conds ...field.Expr) ITUsersRechangeRecordDo
	Distinct(cols ...field.Expr) ITUsersRechangeRecordDo
	Omit(cols ...field.Expr) ITUsersRechangeRecordDo
	Join(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo
	Group(cols ...field.Expr) ITUsersRechangeRecordDo
	Having(conds ...gen.Condition) ITUsersRechangeRecordDo
	Limit(limit int) ITUsersRechangeRecordDo
	Offset(offset int) ITUsersRechangeRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITUsersRechangeRecordDo
	Unscoped() ITUsersRechangeRecordDo
	Create(values ...*model.TUsersRechangeRecord) error
	CreateInBatches(values []*model.TUsersRechangeRecord, batchSize int) error
	Save(values ...*model.TUsersRechangeRecord) error
	First() (*model.TUsersRechangeRecord, error)
	Take() (*model.TUsersRechangeRecord, error)
	Last() (*model.TUsersRechangeRecord, error)
	Find() ([]*model.TUsersRechangeRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUsersRechangeRecord, err error)
	FindInBatches(result *[]*model.TUsersRechangeRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TUsersRechangeRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITUsersRechangeRecordDo
	Assign(attrs ...field.AssignExpr) ITUsersRechangeRecordDo
	Joins(fields ...field.RelationField) ITUsersRechangeRecordDo
	Preload(fields ...field.RelationField) ITUsersRechangeRecordDo
	FirstOrInit() (*model.TUsersRechangeRecord, error)
	FirstOrCreate() (*model.TUsersRechangeRecord, error)
	FindByPage(offset int, limit int) (result []*model.TUsersRechangeRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITUsersRechangeRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tUsersRechangeRecordDo) Debug() ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Debug())
}

func (t tUsersRechangeRecordDo) WithContext(ctx context.Context) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tUsersRechangeRecordDo) ReadDB() ITUsersRechangeRecordDo {
	return t.Clauses(dbresolver.Read)
}

func (t tUsersRechangeRecordDo) WriteDB() ITUsersRechangeRecordDo {
	return t.Clauses(dbresolver.Write)
}

func (t tUsersRechangeRecordDo) Session(config *gorm.Session) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Session(config))
}

func (t tUsersRechangeRecordDo) Clauses(conds ...clause.Expression) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tUsersRechangeRecordDo) Returning(value interface{}, columns ...string) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tUsersRechangeRecordDo) Not(conds ...gen.Condition) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tUsersRechangeRecordDo) Or(conds ...gen.Condition) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tUsersRechangeRecordDo) Select(conds ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tUsersRechangeRecordDo) Where(conds ...gen.Condition) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tUsersRechangeRecordDo) Order(conds ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tUsersRechangeRecordDo) Distinct(cols ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tUsersRechangeRecordDo) Omit(cols ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tUsersRechangeRecordDo) Join(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tUsersRechangeRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tUsersRechangeRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tUsersRechangeRecordDo) Group(cols ...field.Expr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tUsersRechangeRecordDo) Having(conds ...gen.Condition) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tUsersRechangeRecordDo) Limit(limit int) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tUsersRechangeRecordDo) Offset(offset int) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tUsersRechangeRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tUsersRechangeRecordDo) Unscoped() ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tUsersRechangeRecordDo) Create(values ...*model.TUsersRechangeRecord) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tUsersRechangeRecordDo) CreateInBatches(values []*model.TUsersRechangeRecord, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tUsersRechangeRecordDo) Save(values ...*model.TUsersRechangeRecord) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tUsersRechangeRecordDo) First() (*model.TUsersRechangeRecord, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUsersRechangeRecord), nil
	}
}

func (t tUsersRechangeRecordDo) Take() (*model.TUsersRechangeRecord, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUsersRechangeRecord), nil
	}
}

func (t tUsersRechangeRecordDo) Last() (*model.TUsersRechangeRecord, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUsersRechangeRecord), nil
	}
}

func (t tUsersRechangeRecordDo) Find() ([]*model.TUsersRechangeRecord, error) {
	result, err := t.DO.Find()
	return result.([]*model.TUsersRechangeRecord), err
}

func (t tUsersRechangeRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUsersRechangeRecord, err error) {
	buf := make([]*model.TUsersRechangeRecord, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tUsersRechangeRecordDo) FindInBatches(result *[]*model.TUsersRechangeRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tUsersRechangeRecordDo) Attrs(attrs ...field.AssignExpr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tUsersRechangeRecordDo) Assign(attrs ...field.AssignExpr) ITUsersRechangeRecordDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tUsersRechangeRecordDo) Joins(fields ...field.RelationField) ITUsersRechangeRecordDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tUsersRechangeRecordDo) Preload(fields ...field.RelationField) ITUsersRechangeRecordDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tUsersRechangeRecordDo) FirstOrInit() (*model.TUsersRechangeRecord, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUsersRechangeRecord), nil
	}
}

func (t tUsersRechangeRecordDo) FirstOrCreate() (*model.TUsersRechangeRecord, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUsersRechangeRecord), nil
	}
}

func (t tUsersRechangeRecordDo) FindByPage(offset int, limit int) (result []*model.TUsersRechangeRecord, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tUsersRechangeRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tUsersRechangeRecordDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tUsersRechangeRecordDo) Delete(models ...*model.TUsersRechangeRecord) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tUsersRechangeRecordDo) withDO(do gen.Dao) *tUsersRechangeRecordDo {
	t.DO = *do.(*gen.DO)
	return t
}
