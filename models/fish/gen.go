// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fish

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q                 = new(Query)
	CatchChance       *catchChance
	ControlPool       *controlPool
	ControlUser       *controlUser
	Daysendprizevalue *daysendprizevalue
	Fishlog           *fishlog
	Getcoin           *getcoin
	Lv                *lv
	Matchrandking     *matchrandking
	Pool              *pool
	Sendprize         *sendprize
	Shootprize        *shootprize
	TAccount          *tAccount
	TGame             *tGame
	TGamesArchive     *tGamesArchive
	TGuest            *tGuest
	TMessage          *tMessage
	TProperty         *tProperty
	TRoom             *tRoom
	TUser             *tUser
	Usecoin           *usecoin
	Wincoin           *wincoin
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	CatchChance = &Q.CatchChance
	ControlPool = &Q.ControlPool
	ControlUser = &Q.ControlUser
	Daysendprizevalue = &Q.Daysendprizevalue
	Fishlog = &Q.Fishlog
	Getcoin = &Q.Getcoin
	Lv = &Q.Lv
	Matchrandking = &Q.Matchrandking
	Pool = &Q.Pool
	Sendprize = &Q.Sendprize
	Shootprize = &Q.Shootprize
	TAccount = &Q.TAccount
	TGame = &Q.TGame
	TGamesArchive = &Q.TGamesArchive
	TGuest = &Q.TGuest
	TMessage = &Q.TMessage
	TProperty = &Q.TProperty
	TRoom = &Q.TRoom
	TUser = &Q.TUser
	Usecoin = &Q.Usecoin
	Wincoin = &Q.Wincoin
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                db,
		CatchChance:       newCatchChance(db, opts...),
		ControlPool:       newControlPool(db, opts...),
		ControlUser:       newControlUser(db, opts...),
		Daysendprizevalue: newDaysendprizevalue(db, opts...),
		Fishlog:           newFishlog(db, opts...),
		Getcoin:           newGetcoin(db, opts...),
		Lv:                newLv(db, opts...),
		Matchrandking:     newMatchrandking(db, opts...),
		Pool:              newPool(db, opts...),
		Sendprize:         newSendprize(db, opts...),
		Shootprize:        newShootprize(db, opts...),
		TAccount:          newTAccount(db, opts...),
		TGame:             newTGame(db, opts...),
		TGamesArchive:     newTGamesArchive(db, opts...),
		TGuest:            newTGuest(db, opts...),
		TMessage:          newTMessage(db, opts...),
		TProperty:         newTProperty(db, opts...),
		TRoom:             newTRoom(db, opts...),
		TUser:             newTUser(db, opts...),
		Usecoin:           newUsecoin(db, opts...),
		Wincoin:           newWincoin(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	CatchChance       catchChance
	ControlPool       controlPool
	ControlUser       controlUser
	Daysendprizevalue daysendprizevalue
	Fishlog           fishlog
	Getcoin           getcoin
	Lv                lv
	Matchrandking     matchrandking
	Pool              pool
	Sendprize         sendprize
	Shootprize        shootprize
	TAccount          tAccount
	TGame             tGame
	TGamesArchive     tGamesArchive
	TGuest            tGuest
	TMessage          tMessage
	TProperty         tProperty
	TRoom             tRoom
	TUser             tUser
	Usecoin           usecoin
	Wincoin           wincoin
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                db,
		CatchChance:       q.CatchChance.clone(db),
		ControlPool:       q.ControlPool.clone(db),
		ControlUser:       q.ControlUser.clone(db),
		Daysendprizevalue: q.Daysendprizevalue.clone(db),
		Fishlog:           q.Fishlog.clone(db),
		Getcoin:           q.Getcoin.clone(db),
		Lv:                q.Lv.clone(db),
		Matchrandking:     q.Matchrandking.clone(db),
		Pool:              q.Pool.clone(db),
		Sendprize:         q.Sendprize.clone(db),
		Shootprize:        q.Shootprize.clone(db),
		TAccount:          q.TAccount.clone(db),
		TGame:             q.TGame.clone(db),
		TGamesArchive:     q.TGamesArchive.clone(db),
		TGuest:            q.TGuest.clone(db),
		TMessage:          q.TMessage.clone(db),
		TProperty:         q.TProperty.clone(db),
		TRoom:             q.TRoom.clone(db),
		TUser:             q.TUser.clone(db),
		Usecoin:           q.Usecoin.clone(db),
		Wincoin:           q.Wincoin.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                db,
		CatchChance:       q.CatchChance.replaceDB(db),
		ControlPool:       q.ControlPool.replaceDB(db),
		ControlUser:       q.ControlUser.replaceDB(db),
		Daysendprizevalue: q.Daysendprizevalue.replaceDB(db),
		Fishlog:           q.Fishlog.replaceDB(db),
		Getcoin:           q.Getcoin.replaceDB(db),
		Lv:                q.Lv.replaceDB(db),
		Matchrandking:     q.Matchrandking.replaceDB(db),
		Pool:              q.Pool.replaceDB(db),
		Sendprize:         q.Sendprize.replaceDB(db),
		Shootprize:        q.Shootprize.replaceDB(db),
		TAccount:          q.TAccount.replaceDB(db),
		TGame:             q.TGame.replaceDB(db),
		TGamesArchive:     q.TGamesArchive.replaceDB(db),
		TGuest:            q.TGuest.replaceDB(db),
		TMessage:          q.TMessage.replaceDB(db),
		TProperty:         q.TProperty.replaceDB(db),
		TRoom:             q.TRoom.replaceDB(db),
		TUser:             q.TUser.replaceDB(db),
		Usecoin:           q.Usecoin.replaceDB(db),
		Wincoin:           q.Wincoin.replaceDB(db),
	}
}

type queryCtx struct {
	CatchChance       ICatchChanceDo
	ControlPool       IControlPoolDo
	ControlUser       IControlUserDo
	Daysendprizevalue IDaysendprizevalueDo
	Fishlog           IFishlogDo
	Getcoin           IGetcoinDo
	Lv                ILvDo
	Matchrandking     IMatchrandkingDo
	Pool              IPoolDo
	Sendprize         ISendprizeDo
	Shootprize        IShootprizeDo
	TAccount          ITAccountDo
	TGame             ITGameDo
	TGamesArchive     ITGamesArchiveDo
	TGuest            ITGuestDo
	TMessage          ITMessageDo
	TProperty         ITPropertyDo
	TRoom             ITRoomDo
	TUser             ITUserDo
	Usecoin           IUsecoinDo
	Wincoin           IWincoinDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		CatchChance:       q.CatchChance.WithContext(ctx),
		ControlPool:       q.ControlPool.WithContext(ctx),
		ControlUser:       q.ControlUser.WithContext(ctx),
		Daysendprizevalue: q.Daysendprizevalue.WithContext(ctx),
		Fishlog:           q.Fishlog.WithContext(ctx),
		Getcoin:           q.Getcoin.WithContext(ctx),
		Lv:                q.Lv.WithContext(ctx),
		Matchrandking:     q.Matchrandking.WithContext(ctx),
		Pool:              q.Pool.WithContext(ctx),
		Sendprize:         q.Sendprize.WithContext(ctx),
		Shootprize:        q.Shootprize.WithContext(ctx),
		TAccount:          q.TAccount.WithContext(ctx),
		TGame:             q.TGame.WithContext(ctx),
		TGamesArchive:     q.TGamesArchive.WithContext(ctx),
		TGuest:            q.TGuest.WithContext(ctx),
		TMessage:          q.TMessage.WithContext(ctx),
		TProperty:         q.TProperty.WithContext(ctx),
		TRoom:             q.TRoom.WithContext(ctx),
		TUser:             q.TUser.WithContext(ctx),
		Usecoin:           q.Usecoin.WithContext(ctx),
		Wincoin:           q.Wincoin.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
