// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fish

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newMatchrandking(db *gorm.DB, opts ...gen.DOOption) matchrandking {
	_matchrandking := matchrandking{}

	_matchrandking.matchrandkingDo.UseDB(db, opts...)
	_matchrandking.matchrandkingDo.UseModel(&model.Matchrandking{})

	tableName := _matchrandking.matchrandkingDo.TableName()
	_matchrandking.ALL = field.NewAsterisk(tableName)
	_matchrandking.ID = field.NewInt32(tableName, "id")
	_matchrandking.RoomType = field.NewInt32(tableName, "roomType")
	_matchrandking.MatchID = field.NewInt32(tableName, "matchId")
	_matchrandking.UserID = field.NewInt32(tableName, "userId")
	_matchrandking.Score = field.NewInt32(tableName, "score")
	_matchrandking.LastTime = field.NewTime(tableName, "lastTime")
	_matchrandking.WinPropID = field.NewInt32(tableName, "winPropId")
	_matchrandking.WinPropCount = field.NewInt32(tableName, "winPropCount")
	_matchrandking.WinScore = field.NewInt32(tableName, "winScore")
	_matchrandking.RankIdx = field.NewInt32(tableName, "rankIdx")
	_matchrandking.IsGetPrize = field.NewBool(tableName, "isGetPrize")
	_matchrandking.IsMsg = field.NewBool(tableName, "isMsg")
	_matchrandking.Title = field.NewString(tableName, "title")
	_matchrandking.Msg = field.NewString(tableName, "msg")

	_matchrandking.fillFieldMap()

	return _matchrandking
}

type matchrandking struct {
	matchrandkingDo

	ALL          field.Asterisk
	ID           field.Int32
	RoomType     field.Int32 // 房间类型1 1倍房 2 5倍房
	MatchID      field.Int32
	UserID       field.Int32
	Score        field.Int32
	LastTime     field.Time
	WinPropID    field.Int32 // 获得道具ID
	WinPropCount field.Int32 // 获得道具数量
	WinScore     field.Int32 // 获得金币
	RankIdx      field.Int32 // 排名
	IsGetPrize   field.Bool
	IsMsg        field.Bool // 是否是邮件
	Title        field.String
	Msg          field.String

	fieldMap map[string]field.Expr
}

func (m matchrandking) Table(newTableName string) *matchrandking {
	m.matchrandkingDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m matchrandking) As(alias string) *matchrandking {
	m.matchrandkingDo.DO = *(m.matchrandkingDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *matchrandking) updateTableName(table string) *matchrandking {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt32(table, "id")
	m.RoomType = field.NewInt32(table, "roomType")
	m.MatchID = field.NewInt32(table, "matchId")
	m.UserID = field.NewInt32(table, "userId")
	m.Score = field.NewInt32(table, "score")
	m.LastTime = field.NewTime(table, "lastTime")
	m.WinPropID = field.NewInt32(table, "winPropId")
	m.WinPropCount = field.NewInt32(table, "winPropCount")
	m.WinScore = field.NewInt32(table, "winScore")
	m.RankIdx = field.NewInt32(table, "rankIdx")
	m.IsGetPrize = field.NewBool(table, "isGetPrize")
	m.IsMsg = field.NewBool(table, "isMsg")
	m.Title = field.NewString(table, "title")
	m.Msg = field.NewString(table, "msg")

	m.fillFieldMap()

	return m
}

func (m *matchrandking) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *matchrandking) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 14)
	m.fieldMap["id"] = m.ID
	m.fieldMap["roomType"] = m.RoomType
	m.fieldMap["matchId"] = m.MatchID
	m.fieldMap["userId"] = m.UserID
	m.fieldMap["score"] = m.Score
	m.fieldMap["lastTime"] = m.LastTime
	m.fieldMap["winPropId"] = m.WinPropID
	m.fieldMap["winPropCount"] = m.WinPropCount
	m.fieldMap["winScore"] = m.WinScore
	m.fieldMap["rankIdx"] = m.RankIdx
	m.fieldMap["isGetPrize"] = m.IsGetPrize
	m.fieldMap["isMsg"] = m.IsMsg
	m.fieldMap["title"] = m.Title
	m.fieldMap["msg"] = m.Msg
}

func (m matchrandking) clone(db *gorm.DB) matchrandking {
	m.matchrandkingDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m matchrandking) replaceDB(db *gorm.DB) matchrandking {
	m.matchrandkingDo.ReplaceDB(db)
	return m
}

type matchrandkingDo struct{ gen.DO }

type IMatchrandkingDo interface {
	gen.SubQuery
	Debug() IMatchrandkingDo
	WithContext(ctx context.Context) IMatchrandkingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMatchrandkingDo
	WriteDB() IMatchrandkingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMatchrandkingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMatchrandkingDo
	Not(conds ...gen.Condition) IMatchrandkingDo
	Or(conds ...gen.Condition) IMatchrandkingDo
	Select(conds ...field.Expr) IMatchrandkingDo
	Where(conds ...gen.Condition) IMatchrandkingDo
	Order(conds ...field.Expr) IMatchrandkingDo
	Distinct(cols ...field.Expr) IMatchrandkingDo
	Omit(cols ...field.Expr) IMatchrandkingDo
	Join(table schema.Tabler, on ...field.Expr) IMatchrandkingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMatchrandkingDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMatchrandkingDo
	Group(cols ...field.Expr) IMatchrandkingDo
	Having(conds ...gen.Condition) IMatchrandkingDo
	Limit(limit int) IMatchrandkingDo
	Offset(offset int) IMatchrandkingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMatchrandkingDo
	Unscoped() IMatchrandkingDo
	Create(values ...*model.Matchrandking) error
	CreateInBatches(values []*model.Matchrandking, batchSize int) error
	Save(values ...*model.Matchrandking) error
	First() (*model.Matchrandking, error)
	Take() (*model.Matchrandking, error)
	Last() (*model.Matchrandking, error)
	Find() ([]*model.Matchrandking, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Matchrandking, err error)
	FindInBatches(result *[]*model.Matchrandking, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Matchrandking) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMatchrandkingDo
	Assign(attrs ...field.AssignExpr) IMatchrandkingDo
	Joins(fields ...field.RelationField) IMatchrandkingDo
	Preload(fields ...field.RelationField) IMatchrandkingDo
	FirstOrInit() (*model.Matchrandking, error)
	FirstOrCreate() (*model.Matchrandking, error)
	FindByPage(offset int, limit int) (result []*model.Matchrandking, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMatchrandkingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m matchrandkingDo) Debug() IMatchrandkingDo {
	return m.withDO(m.DO.Debug())
}

func (m matchrandkingDo) WithContext(ctx context.Context) IMatchrandkingDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m matchrandkingDo) ReadDB() IMatchrandkingDo {
	return m.Clauses(dbresolver.Read)
}

func (m matchrandkingDo) WriteDB() IMatchrandkingDo {
	return m.Clauses(dbresolver.Write)
}

func (m matchrandkingDo) Session(config *gorm.Session) IMatchrandkingDo {
	return m.withDO(m.DO.Session(config))
}

func (m matchrandkingDo) Clauses(conds ...clause.Expression) IMatchrandkingDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m matchrandkingDo) Returning(value interface{}, columns ...string) IMatchrandkingDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m matchrandkingDo) Not(conds ...gen.Condition) IMatchrandkingDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m matchrandkingDo) Or(conds ...gen.Condition) IMatchrandkingDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m matchrandkingDo) Select(conds ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m matchrandkingDo) Where(conds ...gen.Condition) IMatchrandkingDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m matchrandkingDo) Order(conds ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m matchrandkingDo) Distinct(cols ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m matchrandkingDo) Omit(cols ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m matchrandkingDo) Join(table schema.Tabler, on ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m matchrandkingDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m matchrandkingDo) RightJoin(table schema.Tabler, on ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m matchrandkingDo) Group(cols ...field.Expr) IMatchrandkingDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m matchrandkingDo) Having(conds ...gen.Condition) IMatchrandkingDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m matchrandkingDo) Limit(limit int) IMatchrandkingDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m matchrandkingDo) Offset(offset int) IMatchrandkingDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m matchrandkingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMatchrandkingDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m matchrandkingDo) Unscoped() IMatchrandkingDo {
	return m.withDO(m.DO.Unscoped())
}

func (m matchrandkingDo) Create(values ...*model.Matchrandking) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m matchrandkingDo) CreateInBatches(values []*model.Matchrandking, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m matchrandkingDo) Save(values ...*model.Matchrandking) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m matchrandkingDo) First() (*model.Matchrandking, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchrandking), nil
	}
}

func (m matchrandkingDo) Take() (*model.Matchrandking, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchrandking), nil
	}
}

func (m matchrandkingDo) Last() (*model.Matchrandking, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchrandking), nil
	}
}

func (m matchrandkingDo) Find() ([]*model.Matchrandking, error) {
	result, err := m.DO.Find()
	return result.([]*model.Matchrandking), err
}

func (m matchrandkingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Matchrandking, err error) {
	buf := make([]*model.Matchrandking, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m matchrandkingDo) FindInBatches(result *[]*model.Matchrandking, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m matchrandkingDo) Attrs(attrs ...field.AssignExpr) IMatchrandkingDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m matchrandkingDo) Assign(attrs ...field.AssignExpr) IMatchrandkingDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m matchrandkingDo) Joins(fields ...field.RelationField) IMatchrandkingDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m matchrandkingDo) Preload(fields ...field.RelationField) IMatchrandkingDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m matchrandkingDo) FirstOrInit() (*model.Matchrandking, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchrandking), nil
	}
}

func (m matchrandkingDo) FirstOrCreate() (*model.Matchrandking, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Matchrandking), nil
	}
}

func (m matchrandkingDo) FindByPage(offset int, limit int) (result []*model.Matchrandking, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m matchrandkingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m matchrandkingDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m matchrandkingDo) Delete(models ...*model.Matchrandking) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *matchrandkingDo) withDO(do gen.Dao) *matchrandkingDo {
	m.DO = *do.(*gen.DO)
	return m
}
