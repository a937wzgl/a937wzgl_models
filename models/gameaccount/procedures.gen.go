// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package procedures

import (
	"context"
	"database/sql"
	"fmt"
	"gorm.io/gorm"
)

// ProcedureCaller 存储过程调用器
type ProcedureCaller struct {
	db *gorm.DB
}

// NewProcedureCaller 创建存储过程调用器
func NewProcedureCaller(db *gorm.DB) *ProcedureCaller {
	return &ProcedureCaller{db: db}
}

// Addbankcard 调用存储过程 addBankCard
func (pc *ProcedureCaller) Addbankcard(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL addBankCard()").Error
}

// AddbankcardWithResult 调用存储过程 addBankCard 并返回结果
func (pc *ProcedureCaller) AddbankcardWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL addBankCard()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Adddasub 调用存储过程 AddDaSub
func (pc *ProcedureCaller) Adddasub(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL AddDaSub()").Error
}

// AdddasubWithResult 调用存储过程 AddDaSub 并返回结果
func (pc *ProcedureCaller) AdddasubWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL AddDaSub()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Adddiamond 调用存储过程 AddDiamond
func (pc *ProcedureCaller) Adddiamond(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL AddDiamond()").Error
}

// AdddiamondWithResult 调用存储过程 AddDiamond 并返回结果
func (pc *ProcedureCaller) AdddiamondWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL AddDiamond()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Adddiamondsub 调用存储过程 AddDiamondSub
func (pc *ProcedureCaller) Adddiamondsub(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL AddDiamondSub()").Error
}

// AdddiamondsubWithResult 调用存储过程 AddDiamondSub 并返回结果
func (pc *ProcedureCaller) AdddiamondsubWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL AddDiamondSub()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Addgold 调用存储过程 AddGold
func (pc *ProcedureCaller) Addgold(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL AddGold()").Error
}

// AddgoldWithResult 调用存储过程 AddGold 并返回结果
func (pc *ProcedureCaller) AddgoldWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL AddGold()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Addgoldsub 调用存储过程 AddGoldSub
func (pc *ProcedureCaller) Addgoldsub(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL AddGoldSub()").Error
}

// AddgoldsubWithResult 调用存储过程 AddGoldSub 并返回结果
func (pc *ProcedureCaller) AddgoldsubWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL AddGoldSub()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Addprize 调用存储过程 addPrize
func (pc *ProcedureCaller) Addprize(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL addPrize()").Error
}

// AddprizeWithResult 调用存储过程 addPrize 并返回结果
func (pc *ProcedureCaller) AddprizeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL addPrize()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Changeofficial 调用存储过程 changeOfficial
func (pc *ProcedureCaller) Changeofficial(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL changeOfficial()").Error
}

// ChangeofficialWithResult 调用存储过程 changeOfficial 并返回结果
func (pc *ProcedureCaller) ChangeofficialWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL changeOfficial()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Checkphone 调用存储过程 checkPhone
func (pc *ProcedureCaller) Checkphone(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL checkPhone()").Error
}

// CheckphoneWithResult 调用存储过程 checkPhone 并返回结果
func (pc *ProcedureCaller) CheckphoneWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL checkPhone()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Copyhand 调用存储过程 copyhand
func (pc *ProcedureCaller) Copyhand(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL copyhand()").Error
}

// CopyhandWithResult 调用存储过程 copyhand 并返回结果
func (pc *ProcedureCaller) CopyhandWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL copyhand()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Createrecharge 调用存储过程 createRecharge
func (pc *ProcedureCaller) Createrecharge(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL createRecharge()").Error
}

// CreaterechargeWithResult 调用存储过程 createRecharge 并返回结果
func (pc *ProcedureCaller) CreaterechargeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL createRecharge()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Createuser 调用存储过程 createUser
func (pc *ProcedureCaller) Createuser(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL createUser()").Error
}

// CreateuserWithResult 调用存储过程 createUser 并返回结果
func (pc *ProcedureCaller) CreateuserWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL createUser()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Dongshanzaiqi 调用存储过程 dongshanzaiqi
func (pc *ProcedureCaller) Dongshanzaiqi(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL dongshanzaiqi()").Error
}

// DongshanzaiqiWithResult 调用存储过程 dongshanzaiqi 并返回结果
func (pc *ProcedureCaller) DongshanzaiqiWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL dongshanzaiqi()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Editticket 调用存储过程 EditTicket
func (pc *ProcedureCaller) Editticket(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL EditTicket()").Error
}

// EditticketWithResult 调用存储过程 EditTicket 并返回结果
func (pc *ProcedureCaller) EditticketWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL EditTicket()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Firstexchange 调用存储过程 firstexchange
func (pc *ProcedureCaller) Firstexchange(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL firstexchange()").Error
}

// FirstexchangeWithResult 调用存储过程 firstexchange 并返回结果
func (pc *ProcedureCaller) FirstexchangeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL firstexchange()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Getprize 调用存储过程 getPrize
func (pc *ProcedureCaller) Getprize(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL getPrize()").Error
}

// GetprizeWithResult 调用存储过程 getPrize 并返回结果
func (pc *ProcedureCaller) GetprizeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL getPrize()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Getsendprize 调用存储过程 getSendPrize
func (pc *ProcedureCaller) Getsendprize(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL getSendPrize()").Error
}

// GetsendprizeWithResult 调用存储过程 getSendPrize 并返回结果
func (pc *ProcedureCaller) GetsendprizeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL getSendPrize()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Loginaddtempdiamond 调用存储过程 LoginaddTempDiamond
func (pc *ProcedureCaller) Loginaddtempdiamond(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL LoginaddTempDiamond()").Error
}

// LoginaddtempdiamondWithResult 调用存储过程 LoginaddTempDiamond 并返回结果
func (pc *ProcedureCaller) LoginaddtempdiamondWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL LoginaddTempDiamond()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Loginaddtempscore 调用存储过程 LoginaddTempScore
func (pc *ProcedureCaller) Loginaddtempscore(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL LoginaddTempScore()").Error
}

// LoginaddtempscoreWithResult 调用存储过程 LoginaddTempScore 并返回结果
func (pc *ProcedureCaller) LoginaddtempscoreWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL LoginaddTempScore()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Loginbyphone 调用存储过程 LoginByPhone
func (pc *ProcedureCaller) Loginbyphone(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL LoginByPhone()").Error
}

// LoginbyphoneWithResult 调用存储过程 LoginByPhone 并返回结果
func (pc *ProcedureCaller) LoginbyphoneWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL LoginByPhone()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Loginbyuserpass 调用存储过程 LoginByUserPass
func (pc *ProcedureCaller) Loginbyuserpass(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL LoginByUserPass()").Error
}

// LoginbyuserpassWithResult 调用存储过程 LoginByUserPass 并返回结果
func (pc *ProcedureCaller) LoginbyuserpassWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL LoginByUserPass()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Mark 调用存储过程 mark
func (pc *ProcedureCaller) Mark(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL mark()").Error
}

// MarkWithResult 调用存储过程 mark 并返回结果
func (pc *ProcedureCaller) MarkWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL mark()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Nump 调用存储过程 numP
func (pc *ProcedureCaller) Nump(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL numP()").Error
}

// NumpWithResult 调用存储过程 numP 并返回结果
func (pc *ProcedureCaller) NumpWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL numP()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Passwordlogin 调用存储过程 passwordLogin
func (pc *ProcedureCaller) Passwordlogin(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL passwordLogin()").Error
}

// PasswordloginWithResult 调用存储过程 passwordLogin 并返回结果
func (pc *ProcedureCaller) PasswordloginWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL passwordLogin()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Qureyfee 调用存储过程 qureyFee
func (pc *ProcedureCaller) Qureyfee(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL qureyFee()").Error
}

// QureyfeeWithResult 调用存储过程 qureyFee 并返回结果
func (pc *ProcedureCaller) QureyfeeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL qureyFee()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Qureypc 调用存储过程 qureyPC
func (pc *ProcedureCaller) Qureypc(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL qureyPC()").Error
}

// QureypcWithResult 调用存储过程 qureyPC 并返回结果
func (pc *ProcedureCaller) QureypcWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL qureyPC()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Qureypcv 调用存储过程 qureyPCV
func (pc *ProcedureCaller) Qureypcv(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL qureyPCV()").Error
}

// QureypcvWithResult 调用存储过程 qureyPCV 并返回结果
func (pc *ProcedureCaller) QureypcvWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL qureyPCV()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// RechargeFirst 调用存储过程 recharge_first
func (pc *ProcedureCaller) RechargeFirst(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL recharge_first()").Error
}

// RechargeFirstWithResult 调用存储过程 recharge_first 并返回结果
func (pc *ProcedureCaller) RechargeFirstWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL recharge_first()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Robotname 调用存储过程 robotname
func (pc *ProcedureCaller) Robotname(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL robotname()").Error
}

// RobotnameWithResult 调用存储过程 robotname 并返回结果
func (pc *ProcedureCaller) RobotnameWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL robotname()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Selectlotterylog 调用存储过程 selectlotterylog
func (pc *ProcedureCaller) Selectlotterylog(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL selectlotterylog()").Error
}

// SelectlotterylogWithResult 调用存储过程 selectlotterylog 并返回结果
func (pc *ProcedureCaller) SelectlotterylogWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL selectlotterylog()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Sendemail 调用存储过程 sendEmail
func (pc *ProcedureCaller) Sendemail(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL sendEmail()").Error
}

// SendemailWithResult 调用存储过程 sendEmail 并返回结果
func (pc *ProcedureCaller) SendemailWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL sendEmail()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Tempadddiamond 调用存储过程 tempadddiamond
func (pc *ProcedureCaller) Tempadddiamond(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL tempadddiamond()").Error
}

// TempadddiamondWithResult 调用存储过程 tempadddiamond 并返回结果
func (pc *ProcedureCaller) TempadddiamondWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL tempadddiamond()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Tempaddscore 调用存储过程 tempaddscore
func (pc *ProcedureCaller) Tempaddscore(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL tempaddscore()").Error
}

// TempaddscoreWithResult 调用存储过程 tempaddscore 并返回结果
func (pc *ProcedureCaller) TempaddscoreWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL tempaddscore()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Tempname 调用存储过程 tempname
func (pc *ProcedureCaller) Tempname(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL tempname()").Error
}

// TempnameWithResult 调用存储过程 tempname 并返回结果
func (pc *ProcedureCaller) TempnameWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL tempname()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Updateprop 调用存储过程 updateProp
func (pc *ProcedureCaller) Updateprop(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL updateProp()").Error
}

// UpdatepropWithResult 调用存储过程 updateProp 并返回结果
func (pc *ProcedureCaller) UpdatepropWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL updateProp()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Updaterecharge 调用存储过程 updateRecharge
func (pc *ProcedureCaller) Updaterecharge(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL updateRecharge()").Error
}

// UpdaterechargeWithResult 调用存储过程 updateRecharge 并返回结果
func (pc *ProcedureCaller) UpdaterechargeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL updateRecharge()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Updatescoreout 调用存储过程 updateScoreOut
func (pc *ProcedureCaller) Updatescoreout(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL updateScoreOut()").Error
}

// UpdatescoreoutWithResult 调用存储过程 updateScoreOut 并返回结果
func (pc *ProcedureCaller) UpdatescoreoutWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL updateScoreOut()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// UpdateRechargeFirst 调用存储过程 update_recharge_first
func (pc *ProcedureCaller) UpdateRechargeFirst(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL update_recharge_first()").Error
}

// UpdateRechargeFirstWithResult 调用存储过程 update_recharge_first 并返回结果
func (pc *ProcedureCaller) UpdateRechargeFirstWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL update_recharge_first()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Uselogincode 调用存储过程 useLoginCode
func (pc *ProcedureCaller) Uselogincode(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL useLoginCode()").Error
}

// UselogincodeWithResult 调用存储过程 useLoginCode 并返回结果
func (pc *ProcedureCaller) UselogincodeWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL useLoginCode()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Weixincreateuser 调用存储过程 weixinCreateUser
func (pc *ProcedureCaller) Weixincreateuser(ctx context.Context) error {
	return pc.db.WithContext(ctx).Exec("CALL weixinCreateUser()").Error
}

// WeixincreateuserWithResult 调用存储过程 weixinCreateUser 并返回结果
func (pc *ProcedureCaller) WeixincreateuserWithResult(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	rows, err := pc.db.WithContext(ctx).Raw("CALL weixinCreateUser()").Rows()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		values := make([]interface{}, len(columns))
		scanArgs := make([]interface{}, len(values))
		for i := range values {
			scanArgs[i] = &values[i]
		}

		err = rows.Scan(scanArgs...)
		if err != nil {
			return nil, err
		}

		row := make(map[string]interface{})
		for i, col := range columns {
			row[col] = values[i]
		}
		results = append(results, row)
	}

	return results, nil
}

// Transaction 执行事务中的存储过程
func (pc *ProcedureCaller) Transaction(fc func(tx *ProcedureCaller) error, opts ...*sql.TxOptions) error {
	return pc.db.Transaction(func(tx *gorm.DB) error {
		return fc(NewProcedureCaller(tx))
	}, opts...)
}

// WithContext 设置上下文
func (pc *ProcedureCaller) WithContext(ctx context.Context) *ProcedureCaller {
	return &ProcedureCaller{db: pc.db.WithContext(ctx)}
}
