// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fish

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/a937wzgl/a937wzgl_models/models/model"
)

func newTGuest(db *gorm.DB, opts ...gen.DOOption) tGuest {
	_tGuest := tGuest{}

	_tGuest.tGuestDo.UseDB(db, opts...)
	_tGuest.tGuestDo.UseModel(&model.TGuest{})

	tableName := _tGuest.tGuestDo.TableName()
	_tGuest.ALL = field.NewAsterisk(tableName)
	_tGuest.GuestAccount = field.NewString(tableName, "guest_account")

	_tGuest.fillFieldMap()

	return _tGuest
}

type tGuest struct {
	tGuestDo

	ALL          field.Asterisk
	GuestAccount field.String

	fieldMap map[string]field.Expr
}

func (t tGuest) Table(newTableName string) *tGuest {
	t.tGuestDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tGuest) As(alias string) *tGuest {
	t.tGuestDo.DO = *(t.tGuestDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tGuest) updateTableName(table string) *tGuest {
	t.ALL = field.NewAsterisk(table)
	t.GuestAccount = field.NewString(table, "guest_account")

	t.fillFieldMap()

	return t
}

func (t *tGuest) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tGuest) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 1)
	t.fieldMap["guest_account"] = t.GuestAccount
}

func (t tGuest) clone(db *gorm.DB) tGuest {
	t.tGuestDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tGuest) replaceDB(db *gorm.DB) tGuest {
	t.tGuestDo.ReplaceDB(db)
	return t
}

type tGuestDo struct{ gen.DO }

type ITGuestDo interface {
	gen.SubQuery
	Debug() ITGuestDo
	WithContext(ctx context.Context) ITGuestDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITGuestDo
	WriteDB() ITGuestDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITGuestDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITGuestDo
	Not(conds ...gen.Condition) ITGuestDo
	Or(conds ...gen.Condition) ITGuestDo
	Select(conds ...field.Expr) ITGuestDo
	Where(conds ...gen.Condition) ITGuestDo
	Order(conds ...field.Expr) ITGuestDo
	Distinct(cols ...field.Expr) ITGuestDo
	Omit(cols ...field.Expr) ITGuestDo
	Join(table schema.Tabler, on ...field.Expr) ITGuestDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITGuestDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITGuestDo
	Group(cols ...field.Expr) ITGuestDo
	Having(conds ...gen.Condition) ITGuestDo
	Limit(limit int) ITGuestDo
	Offset(offset int) ITGuestDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITGuestDo
	Unscoped() ITGuestDo
	Create(values ...*model.TGuest) error
	CreateInBatches(values []*model.TGuest, batchSize int) error
	Save(values ...*model.TGuest) error
	First() (*model.TGuest, error)
	Take() (*model.TGuest, error)
	Last() (*model.TGuest, error)
	Find() ([]*model.TGuest, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TGuest, err error)
	FindInBatches(result *[]*model.TGuest, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TGuest) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITGuestDo
	Assign(attrs ...field.AssignExpr) ITGuestDo
	Joins(fields ...field.RelationField) ITGuestDo
	Preload(fields ...field.RelationField) ITGuestDo
	FirstOrInit() (*model.TGuest, error)
	FirstOrCreate() (*model.TGuest, error)
	FindByPage(offset int, limit int) (result []*model.TGuest, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITGuestDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tGuestDo) Debug() ITGuestDo {
	return t.withDO(t.DO.Debug())
}

func (t tGuestDo) WithContext(ctx context.Context) ITGuestDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tGuestDo) ReadDB() ITGuestDo {
	return t.Clauses(dbresolver.Read)
}

func (t tGuestDo) WriteDB() ITGuestDo {
	return t.Clauses(dbresolver.Write)
}

func (t tGuestDo) Session(config *gorm.Session) ITGuestDo {
	return t.withDO(t.DO.Session(config))
}

func (t tGuestDo) Clauses(conds ...clause.Expression) ITGuestDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tGuestDo) Returning(value interface{}, columns ...string) ITGuestDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tGuestDo) Not(conds ...gen.Condition) ITGuestDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tGuestDo) Or(conds ...gen.Condition) ITGuestDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tGuestDo) Select(conds ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tGuestDo) Where(conds ...gen.Condition) ITGuestDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tGuestDo) Order(conds ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tGuestDo) Distinct(cols ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tGuestDo) Omit(cols ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tGuestDo) Join(table schema.Tabler, on ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tGuestDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tGuestDo) RightJoin(table schema.Tabler, on ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tGuestDo) Group(cols ...field.Expr) ITGuestDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tGuestDo) Having(conds ...gen.Condition) ITGuestDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tGuestDo) Limit(limit int) ITGuestDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tGuestDo) Offset(offset int) ITGuestDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tGuestDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITGuestDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tGuestDo) Unscoped() ITGuestDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tGuestDo) Create(values ...*model.TGuest) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tGuestDo) CreateInBatches(values []*model.TGuest, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tGuestDo) Save(values ...*model.TGuest) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tGuestDo) First() (*model.TGuest, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TGuest), nil
	}
}

func (t tGuestDo) Take() (*model.TGuest, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TGuest), nil
	}
}

func (t tGuestDo) Last() (*model.TGuest, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TGuest), nil
	}
}

func (t tGuestDo) Find() ([]*model.TGuest, error) {
	result, err := t.DO.Find()
	return result.([]*model.TGuest), err
}

func (t tGuestDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TGuest, err error) {
	buf := make([]*model.TGuest, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tGuestDo) FindInBatches(result *[]*model.TGuest, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tGuestDo) Attrs(attrs ...field.AssignExpr) ITGuestDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tGuestDo) Assign(attrs ...field.AssignExpr) ITGuestDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tGuestDo) Joins(fields ...field.RelationField) ITGuestDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tGuestDo) Preload(fields ...field.RelationField) ITGuestDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tGuestDo) FirstOrInit() (*model.TGuest, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TGuest), nil
	}
}

func (t tGuestDo) FirstOrCreate() (*model.TGuest, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TGuest), nil
	}
}

func (t tGuestDo) FindByPage(offset int, limit int) (result []*model.TGuest, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tGuestDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tGuestDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tGuestDo) Delete(models ...*model.TGuest) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tGuestDo) withDO(do gen.Dao) *tGuestDo {
	t.DO = *do.(*gen.DO)
	return t
}
